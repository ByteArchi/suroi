{
  "version": 3,
  "sources": ["../../pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts", "../../pixi.js/src/scene/graphics/gpu/colorToUniform.ts", "../../pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts", "../../pixi.js/src/rendering/renderers/shared/shader/types.ts", "../../pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts", "../../pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts", "../../pixi.js/src/scene/sprite/BatchableSprite.ts", "../../pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts", "../../pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts", "../../pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts", "../../pixi.js/src/rendering/renderers/shared/shader/const.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts", "../../pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts", "../../pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts", "../../pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts", "../../pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts", "../../pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts", "../../pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts", "../../pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts", "../../pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts", "../../pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts", "../../pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts", "../../pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts", "../../pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts", "../../pixi.js/src/rendering/renderers/types.ts", "../../pixi.js/src/rendering/renderers/shared/shader/Shader.ts", "../../pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],
  "sourcesContent": ["import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /** should the canvas be resized to preserve its screen width and height regardless of the resolution of the renderer */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        const canvas = options.resource;\n\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height)\n        {\n            this.resizeCanvas();\n        }\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n}\n", "export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n", "const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n", "// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>'\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/* eslint-disable quote-props */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n", "/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n", "import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n", "import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n", "import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n", "import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n", "export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n", "import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n", "export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n", "const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n", "export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n", "import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n", "import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n", "export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n", "export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n", "import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n", "import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n", "import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is layed out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n", "import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n", "export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n", "function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n", "function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n", "/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n", "import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n", "const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n", "export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n", "import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n", "export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n", "import { maxRecommendedTextures } from '../../renderers/shared/texture/utils/maxRecommendedTextures';\n\nimport type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(maxRecommendedTextures())}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(maxRecommendedTextures())}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(maxRecommendedTextures())}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n", "export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n", "import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter weather or not you want to do somthing in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n", "/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\ninterface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\ninterface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\ninterface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            if (!gpuProgram)\n            {\n                // build out a dummy bind group..\n                groupMap = {};\n                groups = {\n                    99: new BindGroup(),\n                };\n\n                this._ownedBindGroups.push(groups[99]);\n\n                let bindTick = 0;\n\n                for (const i in resources)\n                {\n                    // Yes i know this is a little strange, but wil line up the shaders neatly\n                    // basically we want to be driven by how webGPU does things.\n                    // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                    nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                    groupMap[99] = groupMap[99] || {};\n                    groupMap[99][bindTick] = i;\n\n                    bindTick++;\n                }\n            }\n            else\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupMap = {};\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            groups = {};\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],
  "mappings": "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",
  "names": ["_UniformGroup", "_GlProgram", "name", "ShaderStage", "programCache", "RendererType"]
}

{
  "version": 3,
  "sources": ["../../parse-svg-path/index.js", "../../pixi.js/src/ticker/const.ts", "../../pixi.js/src/ticker/TickerListener.ts", "../../pixi.js/src/ticker/Ticker.ts", "../../pixi.js/src/assets/utils/convertToList.ts", "../../pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts", "../../pixi.js/src/assets/cache/Cache.ts", "../../pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts", "../../pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts", "../../pixi.js/src/scene/container/utils/multiplyHexColors.ts", "../../pixi.js/src/scene/graphics/shared/BatchableGraphics.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts", "../../pixi.js/src/scene/graphics/shared/const.ts", "../../pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts", "../../pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts", "../../pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts", "../../pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts", "../../pixi.js/src/scene/graphics/shared/fill/FillGradient.ts", "../../pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts", "../../pixi.js/src/maths/shapes/Circle.ts", "../../pixi.js/src/maths/shapes/Ellipse.ts", "../../pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts", "../../pixi.js/src/maths/shapes/Polygon.ts", "../../pixi.js/src/maths/shapes/RoundedRectangle.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts", "../../pixi.js/src/scene/graphics/shared/path/roundShape.ts", "../../pixi.js/src/scene/graphics/shared/path/ShapePath.ts", "../../pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts", "../../pixi.js/src/scene/graphics/shared/svg/SVGParser.ts", "../../pixi.js/src/scene/graphics/shared/fill/FillPattern.ts", "../../pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts", "../../pixi.js/src/scene/graphics/shared/GraphicsContext.ts", "../../pixi.js/src/scene/text/utils/generateTextStyleKey.ts", "../../pixi.js/src/scene/text/TextStyle.ts", "../../pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts", "../../pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts", "../../pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts", "../../pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts", "../../pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts", "../../pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts", "../../pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts", "../../pixi.js/src/scene/text-bitmap/BitmapFontManager.ts", "../../pixi.js/src/scene/graphics/shared/Graphics.ts", "../../pixi.js/src/scene/text-html/HTMLTextRenderData.ts", "../../pixi.js/src/scene/text-html/utils/textStyleToCSS.ts", "../../pixi.js/src/scene/text-html/HtmlTextStyle.ts", "../../pixi.js/src/scene/text-html/utils/measureHtmlText.ts", "../../pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],
  "sourcesContent": ["\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n", "/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n", "import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n", "import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scaler time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n", "export const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement))\n        {\n            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(options.resource, 0, 0);\n            options.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.');\n            // #endif\n        }\n\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap);\n    }\n}\n", "import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n", "export function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = (r1 * r2) / 255;\n    const g = (g1 * g2) / 255;\n    const b = (b1 * b2) / 255;\n\n    return (r << 16) + (g << 8) + b;\n}\n", "import { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public vertexOffset: number;\n    public vertexSize: number;\n    public color: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometryData.indices;\n\n        for (let i = 0; i < this.indexSize; i++)\n        {\n            indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n\n        const rgb = this.color;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n\n        if (this.applyTransform)\n        {\n            const argb = multiplyHexColors(bgr, graphics.groupColor)\n            + ((this.alpha * graphics.groupAlpha * 255) << 24);\n\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                const x = positions[i];\n                const y = positions[i + 1];\n\n                float32View[index] = (a * x) + (c * y) + tx;\n                float32View[index + 1] = (b * x) + (d * y) + ty;\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n\n                index += 6;\n            }\n        }\n        else\n        {\n            const argb = bgr + ((this.alpha * 255) << 24);\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n\n                index += 6;\n            }\n        }\n    }\n\n    // TODO rename to vertexSize\n    get vertSize()\n    {\n        return this.vertexSize;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n    }\n}\n", "import type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n", "export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n", "export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeStyle } from '../GraphicsContext';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param _verticesStride\n * @param _verticesOffset\n * @param indices\n * @param _indicesOffset\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeStyle,\n    flipAlignment: boolean,\n    closed: boolean,\n    // alignment:number,\n\n    vertices: number[],\n    _verticesStride: number,\n    _verticesOffset: number,\n\n    indices: number[],\n    _indicesOffset: number,\n\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n", "import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n", "import { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n", "import type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = buildMap.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (matrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.color = style.color as number;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = buildMap[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public geometry = new BatchGeometry();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private readonly _activeBatchers: Batcher[] = [];\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    protected prerender()\n    {\n        this._returnActiveBatchers();\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _returnActiveBatchers()\n    {\n        for (let i = 0; i < this._activeBatchers.length; i++)\n        {\n            BigPool.return(this._activeBatchers[i] as PoolItem);\n        }\n\n        this._activeBatchers.length = 0;\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = BigPool.get(Batcher);\n\n        this._activeBatchers.push(batcher);\n\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = graphicsData.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    public readonly uid = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n    }\n}\n", "/* eslint-disable no-console */\nimport parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance < r + w2 && distance > r - w2);\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerA * innerA))\n                           + ((normalizedY * normalizedY) / (innerB * innerB));\n        const outerEllipse = ((normalizedX * normalizedX) / (outerA * outerA))\n                           + ((normalizedY * normalizedY) / (outerB * outerB));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @returns The framing rectangle\n     */\n    public getBounds(): Rectangle\n    {\n        return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n", "export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n", "import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            if (distanceSqrd <= halfStrokeWidthSqrd)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n", "import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n// Check corner within stroke width\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    halfStrokeWidth: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth)\n             || (pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth)\n             || (pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n", "// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n", "export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n", "import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n", "import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n", "import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n", "// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (!lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    public uid = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n", "import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    GraphicsContext,\n    StrokeStyle,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    public readonly uid = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    FillStyle,\n    FillStyleInputs,\n    PatternFillStyle,\n} from '../GraphicsContext';\n\nexport function convertFillInputToFillStyle(\n    value: FillStyleInputs,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    let fillStyleToParse: ConvertedFillStyle;\n    let styleToMerge: FillStyleInputs;\n\n    if ((value as PatternFillStyle)?.fill)\n    {\n        styleToMerge = (value as PatternFillStyle).fill;\n        fillStyleToParse = { ...defaultStyle, ...(value as PatternFillStyle) };\n    }\n    else\n    {\n        styleToMerge = value;\n        fillStyleToParse = defaultStyle;\n    }\n\n    if (Color.isColorLike(styleToMerge as ColorSource))\n    {\n        const temp = Color.shared.setValue(styleToMerge as ColorSource ?? 0);\n        const opts: ConvertedFillStyle = {\n            ...fillStyleToParse,\n            color: temp.toNumber(),\n            alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n            texture: Texture.WHITE,\n        };\n\n        return opts;\n    }\n    else if (styleToMerge instanceof FillPattern)\n    {\n        const pattern = styleToMerge as FillPattern;\n\n        return {\n            ...fillStyleToParse,\n            color: 0xffffff,\n            texture: pattern.texture,\n            matrix: pattern.transform,\n            fill: fillStyleToParse.fill ?? null,\n        };\n    }\n\n    // // TODO Texture\n    else if (styleToMerge instanceof FillGradient)\n    {\n        const gradient = styleToMerge as FillGradient;\n\n        gradient.buildLinearGradient();\n\n        return {\n            ...fillStyleToParse,\n            color: 0xffffff,\n            texture: gradient.texture,\n            matrix: gradient.transform,\n        };\n    }\n\n    const style: FillStyle = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.invert() || new Matrix();\n\n            m.scale(\n                1 / style.texture.frame.width,\n                1 / style.texture.frame.height\n            );\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    // its a regular fill style!\n    return style as ConvertedFillStyle;\n}\n", "/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { LineCap, LineJoin } from './const';\nimport type { FillGradient } from './fill/FillGradient';\nimport type { FillPattern } from './fill/FillPattern';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * A fill style object.\n * @memberof scene\n */\nexport interface FillStyle\n{\n    /** The color to use for the fill. */\n    color?: ColorSource;\n    /** The alpha value to use for the fill. */\n    alpha?: number;\n    /** The texture to use for the fill. */\n    texture?: Texture | null;\n    /** The matrix to apply. */\n    matrix?: Matrix | null;\n    /** The fill pattern to use. */\n    fill?: FillPattern | FillGradient | null;\n}\n\nexport type ConvertedFillStyle = Omit<Required<FillStyle>, 'color'> & { color: number };\n\nexport interface PatternFillStyle\n{\n    fill?: FillPattern | FillGradient;\n    color?: number;\n    alpha?: number;\n}\n\n/**\n * A stroke style object.\n * @memberof scene\n */\nexport interface StrokeStyle extends FillStyle\n{\n    /** The width of the stroke. */\n    width?: number;\n    /** The alignment of the stroke. */\n    alignment?: number;\n    // native?: boolean;\n    /** The line cap style to use. */\n    cap?: LineCap;\n    /** The line join style to use. */\n    join?: LineJoin;\n    /** The miter limit to use. */\n    miterLimit?: number;\n}\n\nexport type ConvertedStrokeStyle = Omit<StrokeStyle, 'color'> & ConvertedFillStyle;\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport type FillStyleInputs = ColorSource | FillGradient | CanvasPattern | PatternFillStyle | FillStyle | ConvertedFillStyle | StrokeStyle | ConvertedStrokeStyle;\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    public uid = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._fillStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._strokeStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillStyleInputs): this\n    {\n        this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: FillStyleInputs): this\n    {\n        this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillStyleInputs, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: FillStyleInputs): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const padding = data.style.width / 2;\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - padding,\n                    _bounds.minY - padding,\n                    _bounds.maxX + padding,\n                    _bounds.maxY + padding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, (style as ConvertedStrokeStyle).width);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n", "import type { FillGradient } from '../../graphics/shared/fill/FillGradient';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys = [\n    '_fontFamily',\n    '_fontStyle',\n    '_fontSize',\n    '_fontVariant',\n    '_fontWeight',\n    '_breakWords',\n    '_align',\n    '_leading',\n    '_letterSpacing',\n    '_lineHeight',\n    '_textBaseline',\n    '_whiteSpace',\n    '_wordWrap',\n    '_wordWrapWidth',\n    '_padding',\n    '_cssOverrides',\n    '_trim'\n];\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = valuesToIterateForKeys[i];\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n\n    // TODO - we need to add some shadow stuff here!\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = (fillStyle.fill as FillGradient)?.uid;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { convertFillInputToFillStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    FillStyleInputs\n} from '../graphics/shared/GraphicsContext';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillStyleInputs;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: FillStyleInputs;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillStyleInputs;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: FillStyleInputs;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = {\n                ...TextStyle.defaultDropShadow as TextDropShadow,\n                ...value as TextDropShadow\n            };\n        }\n        else\n        {\n            this._dropShadow = value ? {\n                ...TextStyle.defaultDropShadow as TextDropShadow\n            } : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle) { this._fontStyle = value; this.update(); }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillStyleInputs\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillStyleInputs)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n        this._fill = convertFillInputToFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): FillStyleInputs\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: FillStyleInputs)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as any;\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n\n        style.stroke = {\n            color,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fill))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        const gradientFill = new FillGradient(0, 0, 0, (style.fontSize as number) * 1.7);\n\n        const fills: number[] = oldStyle.fill.map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n", "import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth * 2))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        let width = context.measureText(text).width;\n\n        if (width > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                width -= letterSpacing;\n            }\n            else\n            {\n                width += (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n            }\n        }\n\n        return width;\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convienience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/GraphicsContext';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).toHex();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill as FillPattern;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill as FillGradient;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n", "import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            this.chars[i].texture.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n", "/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n", "import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n", "import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n", "import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill)\n        {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fnt.once('destroy', () => Cache.remove(fontFamilyKey));\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     */\n    public getLayout(text: string, style: TextStyle): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout([...text], style, bitmapFont);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     */\n    public measureText(text: string, style: TextStyle): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            Cache.remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillStyle, FillStyleInputs, StrokeStyle } from './GraphicsContext';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends Container implements View, Instruction\n{\n    public readonly canBundle = true;\n    public readonly renderPipeId = 'graphics';\n    public batched: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    public _didGraphicsUpdate: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the graphic.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    protected onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didGraphicsUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param {FillStyleInputs} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(...args: [FillStyleInputs, ColorSource?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n", "import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n", "import { Color } from '../../../color/Color';\n\nimport type { StrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: StrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n", "/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillStyleInputs } from '../graphics/shared/GraphicsContext';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n", "import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n", "import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],
  "mappings": "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",
  "names": ["parse", "UPDATE_PRIORITY", "_Ticker", "transform", "key", "y2", "x0", "y0", "x1", "x2", "y1", "earcut", "_GraphicsContextSystem", "_FillGradient", "parse", "out", "out", "out", "RECURSION_LIMIT", "FLT_EPSILON", "PATH_DISTANCE_EPSILON", "curveAngleToleranceEpsilon", "mAngleTolerance", "begin", "recursive", "out", "transform", "transform", "out", "transform", "_GraphicsContext", "transform", "_TextStyle", "_CanvasTextMetrics", "tempMatrix", "i", "j", "pageData", "out", "_MeshGeometry"]
}

import {
  __commonJS,
  __publicField
} from "./chunk-UV5CTPV7.js";

// ../common/node_modules/@damienvesper/bit-buffer/dist/BitView.js
var require_BitView = __commonJS({
  "../common/node_modules/@damienvesper/bit-buffer/dist/BitView.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitView = void 0;
    var BitView = class {
      constructor(source, byteOffset, byteLength) {
        __publicField(this, "_view");
        // Used to massage fp values so they can be operated upon at the bit level.
        __publicField(this, "_scratch", new DataView(new ArrayBuffer(8)));
        __publicField(this, "bigEndian");
        __publicField(this, "_setBit", (offset, on) => {
          on ? this._view[offset >> 3] |= 1 << (offset & 7) : this._view[offset >> 3] &= ~(1 << (offset & 7));
        });
        __publicField(this, "getBits", (offset, bits, signed) => {
          const available = this._view.length * 8 - offset;
          if (bits > available) {
            throw new Error(`Cannot get ${bits} bit(s) from offset ${offset}, ${available} available`);
          }
          let value = 0;
          for (let i = 0; i < bits; ) {
            const remaining = bits - i;
            const bitOffset = offset & 7;
            const currentByte = this._view[offset >> 3];
            const read = Math.min(remaining, 8 - bitOffset);
            let mask;
            let readBits;
            if (this.bigEndian) {
              mask = ~(255 << read);
              readBits = currentByte >> 8 - read - bitOffset & mask;
              value <<= read;
              value |= readBits;
            } else {
              mask = ~(255 << read);
              readBits = currentByte >> bitOffset & mask;
              value |= readBits << i;
            }
            offset += read;
            i += read;
          }
          if (signed) {
            if (bits !== 32 && Boolean(value & 1 << bits - 1)) {
              value |= -1 ^ (1 << bits) - 1;
            }
            return value;
          }
          return value >>> 0;
        });
        __publicField(this, "setBits", (offset, value, bits) => {
          const available = this._view.length * 8 - offset;
          if (bits > available) {
            throw new Error(`Cannot set ${bits} bit(s) from offset ${offset}, ${available} available`);
          }
          for (let i = 0; i < bits; ) {
            const remaining = bits - i;
            const bitOffset = offset & 7;
            const byteOffset = offset >> 3;
            const wrote = Math.min(remaining, 8 - bitOffset);
            let mask;
            let writeBits;
            let destMask;
            if (this.bigEndian) {
              mask = ~(~0 << wrote);
              writeBits = value >> bits - i - wrote & mask;
              const destShift = 8 - bitOffset - wrote;
              destMask = ~(mask << destShift);
              this._view[byteOffset] = this._view[byteOffset] & destMask | writeBits << destShift;
            } else {
              mask = ~(255 << wrote);
              writeBits = value & mask;
              value >>= wrote;
              destMask = ~(mask << bitOffset);
              this._view[byteOffset] = this._view[byteOffset] & destMask | writeBits << bitOffset;
            }
            offset += wrote;
            i += wrote;
          }
        });
        __publicField(this, "getBoolean", (offset) => this.getBits(offset, 1, false) !== 0);
        __publicField(this, "getInt8", (offset) => this.getBits(offset, 8, true));
        __publicField(this, "getInt16", (offset) => this.getBits(offset, 16, true));
        __publicField(this, "getInt32", (offset) => this.getBits(offset, 32, true));
        __publicField(this, "getUint8", (offset) => this.getBits(offset, 8, false));
        __publicField(this, "getUint16", (offset) => this.getBits(offset, 16, false));
        __publicField(this, "getUint32", (offset) => this.getBits(offset, 32, false));
        __publicField(this, "getFloat32", (offset) => {
          this._scratch.setUint32(0, this.getUint32(offset));
          return this._scratch.getFloat32(0);
        });
        __publicField(this, "getFloat64", (offset) => {
          this._scratch.setUint32(0, this.getUint32(offset));
          this._scratch.setUint32(4, this.getUint32(offset + 32));
          return this._scratch.getFloat64(0);
        });
        __publicField(this, "setBoolean", (offset, value) => {
          this.setBits(offset, value ? 1 : 0, 1);
        });
        __publicField(this, "setInt8", (offset, value) => {
          this.setBits(offset, value, 8);
        });
        __publicField(this, "setInt16", (offset, value) => {
          this.setBits(offset, value, 16);
        });
        __publicField(this, "setInt32", (offset, value) => {
          this.setBits(offset, value, 32);
        });
        __publicField(this, "setUint8", this.setInt8);
        __publicField(this, "setUint16", this.setInt16);
        __publicField(this, "setUint32", this.setInt32);
        __publicField(this, "setFloat32", (offset, value) => {
          this._scratch.setFloat32(0, value);
          this.setBits(offset, this._scratch.getUint32(0), 32);
        });
        __publicField(this, "setFloat64", (offset, value) => {
          this._scratch.setFloat64(0, value);
          this.setBits(offset, this._scratch.getUint32(0), 32);
          this.setBits(offset + 32, this._scratch.getUint32(4), 32);
        });
        __publicField(this, "getArrayBuffer", (offset, byteLength) => {
          const buffer = new Uint8Array(byteLength);
          for (let i = 0; i < byteLength; i++) {
            buffer[i] = this.getUint8(offset + i * 8);
          }
          return buffer;
        });
        const isBuffer = source instanceof ArrayBuffer || typeof Buffer !== `undefined` && source instanceof Buffer;
        if (!isBuffer) {
          throw new Error(`Must specify a valid ArrayBuffer or Buffer`);
        }
        byteOffset = byteOffset ?? 0;
        byteLength = (byteLength ?? 0) || (source instanceof ArrayBuffer ? source.byteLength - byteOffset : source.length - byteOffset);
        if (byteLength === 0) {
          byteLength = source instanceof ArrayBuffer ? source.byteLength : source.length;
        }
        this._view = new Uint8Array(typeof Buffer !== `undefined` && source instanceof Buffer ? source.buffer : source, byteOffset, byteLength);
        this.bigEndian = false;
      }
      get buffer() {
        return typeof Buffer !== `undefined` ? Buffer.from(this._view.buffer) : this._view.buffer;
      }
      get byteLength() {
        return this._view.length;
      }
    };
    exports.BitView = BitView;
  }
});

// ../common/node_modules/@damienvesper/bit-buffer/dist/utils.js
var require_utils = __commonJS({
  "../common/node_modules/@damienvesper/bit-buffer/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeUTF8String = exports.writeASCIIString = exports.readUTF8String = exports.readASCIIString = exports.stringToByteArray = void 0;
    var readString = (stream, length, index, utf8, bytes) => {
      if (bytes === 0)
        return ``;
      let i = 0;
      const chars = [];
      let append = true;
      const fixedLength = Boolean(bytes);
      if (bytes === void 0)
        bytes = Math.floor(length - index);
      while (i < bytes) {
        const c = stream.readUint8();
        if (c === 0) {
          append = false;
          if (!fixedLength)
            break;
        }
        if (append)
          chars.push(c);
        i++;
      }
      const string = String.fromCharCode.apply(null, chars);
      if (utf8) {
        try {
          return decodeURIComponent(escape(string));
        } catch (err) {
          console.warn(err);
          return string;
        }
      } else
        return string;
    };
    var stringToByteArray = (str) => {
      const b = [];
      let unicode;
      for (let i = 0; i < str.length; i++) {
        unicode = str.charCodeAt(i);
        if (unicode <= 127) {
          b.push(unicode);
        } else if (unicode <= 2047) {
          b.push(unicode >> 6 | 192);
          b.push(unicode & 63 | 128);
        } else if (unicode <= 65535) {
          b.push(unicode >> 12 | 224);
          b.push(unicode >> 6 & 63 | 128);
          b.push(unicode & 63 | 128);
        } else {
          b.push(unicode >> 18 | 240);
          b.push(unicode >> 12 & 63 | 128);
          b.push(unicode >> 6 & 63 | 128);
          b.push(unicode & 63 | 128);
        }
      }
      return b;
    };
    exports.stringToByteArray = stringToByteArray;
    var readASCIIString = (stream, length, index, bytes) => readString(stream, length, index, false, bytes);
    exports.readASCIIString = readASCIIString;
    var readUTF8String = (stream, length, index, bytes) => readString(stream, length, index, true, bytes);
    exports.readUTF8String = readUTF8String;
    var writeASCIIString = (stream, string, bytes) => {
      const length = (bytes ?? 0) || string.length + 1;
      for (let i = 0; i < length; i++) {
        stream.writeUint8(i < string.length ? string.charCodeAt(i) : 0);
      }
    };
    exports.writeASCIIString = writeASCIIString;
    var writeUTF8String = (stream, string, bytes) => {
      const byteArray = (0, exports.stringToByteArray)(string);
      const length = (bytes ?? 0) || byteArray.length + 1;
      for (let i = 0; i < length; i++) {
        stream.writeUint8(i < byteArray.length ? byteArray[i] : 0);
      }
    };
    exports.writeUTF8String = writeUTF8String;
  }
});

// ../common/node_modules/@damienvesper/bit-buffer/dist/BitStream.js
var require_BitStream = __commonJS({
  "../common/node_modules/@damienvesper/bit-buffer/dist/BitStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitStream = void 0;
    var BitView_1 = require_BitView();
    var utils_1 = require_utils();
    var BitStream = class _BitStream {
      constructor(source, byteOffset, byteLength) {
        __publicField(this, "_view");
        __publicField(this, "_startIndex");
        __publicField(this, "_length");
        __publicField(this, "_index");
        __publicField(this, "reader", (name, size) => () => {
          if (this._index + size > this._length) {
            throw new Error(`Trying to read past the end of the stream`);
          }
          const val = this._view[name](this._index);
          this._index += size;
          return val;
        });
        __publicField(this, "writer", (name, size) => (value) => {
          this._view[name](this._index, value);
          this._index += size;
        });
        __publicField(this, "readBits", (bits, signed) => {
          const val = this._view.getBits(this._index, bits, signed ?? false);
          this._index += bits;
          return val;
        });
        __publicField(this, "writeBits", (value, bits) => {
          this._view.setBits(this._index, value, bits);
          this._index += bits;
        });
        __publicField(this, "readBoolean", this.reader(`getBoolean`, 1));
        __publicField(this, "readInt8", this.reader(`getInt8`, 8));
        __publicField(this, "readInt16", this.reader(`getInt16`, 16));
        __publicField(this, "readInt32", this.reader(`getInt32`, 32));
        __publicField(this, "readUint8", this.reader(`getUint8`, 8));
        __publicField(this, "readUint16", this.reader(`getUint16`, 16));
        __publicField(this, "readUint32", this.reader(`getUint32`, 32));
        __publicField(this, "readFloat32", this.reader(`getFloat32`, 32));
        __publicField(this, "readFloat64", this.reader(`getFloat64`, 64));
        __publicField(this, "writeBoolean", this.writer(`setBoolean`, 1));
        __publicField(this, "writeInt8", this.writer(`setInt8`, 8));
        __publicField(this, "writeInt16", this.writer(`setInt16`, 16));
        __publicField(this, "writeInt32", this.writer(`setInt32`, 32));
        __publicField(this, "writeUint8", this.writer(`setUint8`, 8));
        __publicField(this, "writeUint16", this.writer(`setUint16`, 16));
        __publicField(this, "writeUint32", this.writer(`setUint32`, 32));
        __publicField(this, "writeFloat32", this.writer(`setFloat32`, 32));
        __publicField(this, "writeFloat64", this.writer(`setFloat64`, 64));
        __publicField(this, "readASCIIString", (bytes) => (0, utils_1.readASCIIString)(this, this._length, this._index, bytes));
        __publicField(this, "readUTF8String", (bytes) => (0, utils_1.readUTF8String)(this, this._length, this._index, bytes));
        __publicField(this, "writeASCIIString", (string, bytes) => {
          (0, utils_1.writeASCIIString)(this, string, bytes);
        });
        __publicField(this, "writeUTF8String", (string, bytes) => {
          (0, utils_1.writeUTF8String)(this, string, bytes);
        });
        __publicField(this, "readBitStream", (bitLength) => {
          const slice = new _BitStream(this._view);
          slice._startIndex = this._index;
          slice._index = this._index;
          slice.length = bitLength;
          this._index += bitLength;
          return slice;
        });
        __publicField(this, "writeBitStream", (stream, length) => {
          if (length === void 0)
            length = stream.bitsLeft;
          let bitsToWrite;
          while (length > 0) {
            bitsToWrite = Math.min(length, 32);
            this.writeBits(stream.readBits(bitsToWrite), bitsToWrite);
            length -= bitsToWrite;
          }
        });
        __publicField(this, "readArrayBuffer", (byteLength) => {
          const buffer = this._view.getArrayBuffer(this._index, byteLength);
          this._index += byteLength * 8;
          return buffer;
        });
        __publicField(this, "writeArrayBuffer", (buffer, byteLength) => {
          this.writeBitStream(new _BitStream(buffer), byteLength * 8);
        });
        const isBuffer = source instanceof ArrayBuffer || typeof Buffer !== `undefined` && source instanceof Buffer;
        if (!(source instanceof BitView_1.BitView) && !isBuffer) {
          throw new Error(`Must specify a valid BitView, ArrayBuffer or Buffer`);
        }
        byteOffset = byteOffset ?? 0;
        byteLength = (byteLength ?? 0) || (source instanceof ArrayBuffer || source instanceof BitView_1.BitView ? source.byteLength : source.length);
        this._view = !(source instanceof BitView_1.BitView) ? new BitView_1.BitView(source, byteOffset, byteLength) : source;
        this._index = 0;
        this._startIndex = 0;
        this._length = this._view.byteLength * 8;
      }
      get index() {
        return this._index - this._startIndex;
      }
      set index(val) {
        this._index = val + this._startIndex;
      }
      get length() {
        return this._length - this._startIndex;
      }
      set length(val) {
        this._length = val + this._startIndex;
      }
      get bitsLeft() {
        return this._length - this._index;
      }
      get byteIndex() {
        return Math.ceil(this._index / 8);
      }
      set byteIndex(val) {
        this._index = val * 8;
      }
      get buffer() {
        return this._view.buffer;
      }
      get view() {
        return this._view;
      }
      get bigEndian() {
        return this._view.bigEndian;
      }
      set bigEndian(val) {
        this._view.bigEndian = val;
      }
    };
    exports.BitStream = BitStream;
  }
});

// ../common/node_modules/@damienvesper/bit-buffer/dist/index.js
var require_dist = __commonJS({
  "../common/node_modules/@damienvesper/bit-buffer/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BitStream(), exports);
    __exportStar(require_BitView(), exports);
  }
});
export default require_dist();
//# sourceMappingURL=@damienvesper_bit-buffer.js.map

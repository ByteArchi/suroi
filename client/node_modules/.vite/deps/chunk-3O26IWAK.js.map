{
  "version": 3,
  "sources": ["../../pixi.js/src/maths/point/pointInTriangle.ts", "../../pixi.js/src/prepare/PrepareBase.ts", "../../pixi.js/src/scene/mesh/shared/Mesh.ts", "../../pixi.js/src/scene/sprite-animated/AnimatedSprite.ts", "../../pixi.js/src/utils/misc/Transform.ts", "../../pixi.js/src/scene/sprite-tiling/TilingSprite.ts", "../../pixi.js/src/scene/text/AbstractText.ts", "../../pixi.js/src/scene/text/Text.ts", "../../pixi.js/src/prepare/PrepareQueue.ts", "../../pixi.js/src/scene/text-bitmap/BitmapText.ts", "../../pixi.js/src/scene/text-html/HTMLText.ts", "../../pixi.js/src/prepare/PrepareUpload.ts", "../../pixi.js/src/prepare/PrepareSystem.ts"],
  "sourcesContent": ["/**\n * Check if a point is inside a triangle.\n * @param px - x coordinate of the point\n * @param py - y coordinate of the point\n * @param x1 - x coordinate of the first vertex of the triangle\n * @param y1 - y coordinate of the first vertex of the triangle\n * @param x2 - x coordinate of the second vertex of the triangle\n * @param y2 - y coordinate of the second vertex of the triangle\n * @param x3 - x coordinate of the third vertex of the triangle\n * @param y3 - y coordinate of the third vertex of the triangle\n * @returns `true` if the point is inside the triangle, `false` otherwise\n */\nexport function pointInTriangle(\n    px: number, py: number,\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number\n)\n{\n    // Calculate vectors from point p to each vertex of the triangle\n    const v2x = x3 - x1;\n    const v2y = y3 - y1;\n    const v1x = x2 - x1;\n    const v1y = y2 - y1;\n    const v0x = px - x1;\n    const v0y = py - y1;\n\n    // Compute dot products\n    const dot00 = (v2x * v2x) + (v2y * v2y);\n    const dot01 = (v2x * v1x) + (v2y * v1y);\n    const dot02 = (v2x * v0x) + (v2y * v0y);\n    const dot11 = (v1x * v1x) + (v1y * v1y);\n    const dot12 = (v1x * v0x) + (v1y * v0y);\n\n    // Calculate barycentric coordinates\n    const invDenom = 1 / ((dot00 * dot11) - (dot01 * dot01));\n    const u = ((dot11 * dot02) - (dot01 * dot12)) * invDenom;\n    const v = ((dot00 * dot12) - (dot01 * dot02)) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n}\n", "import { Container } from '../scene/container/Container';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport type { Text } from '../scene/text/Text';\n\n/** The accepted types to pass to the prepare system */\nexport type PrepareSourceItem = Container | TextureSource | Texture | GraphicsContext;\n\n/** The valid types resolved to the queue ready for upload */\nexport type PrepareQueueItem = TextureSource | Text | GraphicsContext;\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class provides the base functionality and handles processing the queue asynchronously.\n * @memberof rendering\n */\nexport abstract class PrepareBase\n{\n    /** The number of uploads to process per frame */\n    public static uploadsPerFrame = 4;\n\n    /** Reference to the renderer */\n    protected renderer: Renderer;\n\n    /** The queue to process over a async timer */\n    protected queue: PrepareQueueItem[];\n\n    /** Collection of callbacks to call when the uploads are finished */\n    protected resolves: ((value: void | PromiseLike<void>) => void)[];\n\n    /** Timeout id for next processing call */\n    protected timeout?: number;\n\n    /**\n     * * @param {Renderer} renderer - A reference to the current renderer\n     * @param renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.queue = [];\n        this.resolves = [];\n    }\n\n    /** Resolve the given resource type and return an item for the queue */\n    protected abstract resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void;\n    protected abstract uploadQueueItem(item: PrepareQueueItem): void;\n\n    /**\n     * Return a copy of the queue\n     * @returns {PrepareQueueItem[]} The queue\n     */\n    public getQueue(): PrepareQueueItem[]\n    {\n        return [...this.queue];\n    }\n\n    /**\n     * Add a textures or graphics resource to the queue\n     * @param {PrepareSourceItem | PrepareSourceItem[]} resource\n     */\n    public add(resource: PrepareSourceItem | PrepareSourceItem[]): this\n    {\n        const resourceArray = Array.isArray(resource) ? resource : [resource];\n\n        for (const resourceItem of resourceArray)\n        {\n            // handle containers and their children\n            if (resourceItem instanceof Container)\n            {\n                this._addContainer(resourceItem);\n            }\n            else\n            {\n                this.resolveQueueItem(resourceItem, this.queue);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Recursively add a container and its children to the queue\n     * @param {Container} container - The container to add to the queue\n     */\n    private _addContainer(container: Container): void\n    {\n        this.resolveQueueItem(container, this.queue);\n\n        // recursively add children\n        for (const child of container.children)\n        {\n            this._addContainer(child);\n        }\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)\n     * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource\n     */\n    public upload(resource?: PrepareSourceItem | PrepareSourceItem[]): Promise<void>\n    {\n        if (resource)\n        {\n            this.add(resource);\n        }\n\n        return new Promise((resolve) =>\n        {\n            if (this.queue.length)\n            {\n                // add resolve callback to the collection\n                this.resolves.push(resolve);\n\n                // eliminate duplicates first\n                this.dedupeQueue();\n\n                // launch first tick\n                Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n            else\n            {\n                // queue is empty, resolve immediately\n                resolve();\n            }\n        });\n    }\n\n    /** eliminate duplicates before processing */\n    public dedupeQueue(): void\n    {\n        const hash = Object.create(null);\n        let nextUnique = 0;\n\n        for (let i = 0; i < this.queue.length; i++)\n        {\n            const current = this.queue[i];\n\n            if (!hash[current.uid])\n            {\n                hash[current.uid] = true;\n                this.queue[nextUnique++] = current;\n            }\n        }\n\n        this.queue.length = nextUnique;\n    }\n\n    /** called per frame by the ticker, defer processing to next tick */\n    private readonly _tick = () =>\n    {\n        this.timeout = setTimeout(this._processQueue, 0) as unknown as number;\n    };\n\n    /** process the queue up to max item limit per frame */\n    private readonly _processQueue = () =>\n    {\n        const { queue } = this;\n        let itemsProcessed = 0;\n\n        // process the maximum number of items per frame\n        while (queue.length && itemsProcessed < PrepareBase.uploadsPerFrame)\n        {\n            const queueItem = queue.shift();\n\n            this.uploadQueueItem(queueItem);\n\n            itemsProcessed++;\n        }\n\n        if (queue.length)\n        {\n            // queue is not empty, continue processing on next frame\n            Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n        else\n        {\n            // queue is empty, resolve immediately\n            this._resolve();\n        }\n    };\n\n    /** Call all the resolve callbacks */\n    private _resolve(): void\n    {\n        const { resolves } = this;\n\n        // call all resolve callbacks\n        const array = resolves.slice(0);\n\n        resolves.length = 0;\n\n        for (const resolve of array)\n        {\n            resolve();\n        }\n    }\n}\n", "import { pointInTriangle } from '../../../maths/point/pointInTriangle';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { MeshGeometry } from './MeshGeometry';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\n\nexport interface TextureShader extends Shader\n{\n    texture: Texture;\n}\n\n/**\n * Constructor options used for `Mesh` instances. Extends {@link scene.MeshViewOptions}\n * ```js\n * const mesh = new Mesh({\n *    texture: Texture.from('assets/image.png'),\n *    geometry: new PlaneGeometry(),\n *    shader: Shader.from(VERTEX, FRAGMENT),\n * });\n * ```\n * @see {@link scene.Mesh}\n * @see {@link scene.MeshViewOptions}\n * @memberof scene\n */\n\n/**\n * @memberof scene\n */\nexport interface MeshOptions<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ContainerOptions\n{\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    geometry: GEOMETRY;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    shader?: SHADER;\n    /** The state of WebGL required to render the mesh. */\n    state?: State;\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    texture?: Texture;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL/WebGPU visuals you can think of.\n * This class assumes a certain level of WebGL/WebGPU knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL/WebGPU can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof scene\n */\nexport class Mesh<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends Container implements View, Instruction\n{\n    public readonly renderPipeId = 'mesh';\n    public readonly canBundle = true;\n    public state: State;\n\n    /** @ignore */\n    public _texture: Texture;\n    /** @ignore */\n    public _geometry: GEOMETRY;\n    /** @ignore */\n    public _shader?: SHADER;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param {scene.MeshOptions} options - options for the mesh instance\n     */\n    constructor(options: MeshOptions<GEOMETRY, SHADER>);\n    /** @deprecated since 8.0.0 */\n    constructor(geometry: GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology);\n    constructor(...args: [MeshOptions<GEOMETRY, SHADER>] | [GEOMETRY, SHADER, State?, Topology?])\n    {\n        let options = args[0];\n\n        if (options instanceof Geometry)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'Mesh: use new Mesh({ geometry, shader }) instead');\n            // #endif\n\n            options = {\n                geometry: options,\n                shader: args[1],\n            } as MeshOptions<GEOMETRY, SHADER>;\n\n            if (args[3])\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'Mesh: drawMode argument has been removed, use geometry.topology instead');\n                // #endif\n\n                options.geometry.topology = args[3];\n            }\n        }\n\n        const { geometry, shader, texture, roundPixels, state, ...rest } = options;\n\n        super({\n            label: 'Mesh',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this.shader = shader;\n        this.texture = texture ?? (shader as unknown as TextureShader)?.texture ?? Texture.WHITE;\n        this.state = state ?? State.for2d();\n\n        this._geometry = geometry;\n        this._geometry.on('update', this.onViewUpdate, this);\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the mesh.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** Alias for {@link scene.Mesh#shader}. */\n    get material()\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'mesh.material property has been removed, use mesh.shader instead');\n        // #endif\n\n        return this._shader;\n    }\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    set shader(value: SHADER)\n    {\n        if (this._shader === value) return;\n\n        this._shader = value;\n        this.onViewUpdate();\n    }\n\n    get shader()\n    {\n        return this._shader;\n    }\n\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    set geometry(value: GEOMETRY)\n    {\n        if (this._geometry === value) return;\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n        value.on('update', this.onViewUpdate, this);\n\n        this._geometry = value;\n        this.onViewUpdate();\n    }\n\n    get geometry()\n    {\n        return this._geometry;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        if (this.shader)\n        {\n            (this.shader as unknown as TextureShader).texture = value;\n        }\n\n        this._texture = value;\n        this.onViewUpdate();\n    }\n\n    get texture()\n    {\n        return this._texture;\n    }\n\n    get batched()\n    {\n        if (this._shader) return false;\n\n        if (this._geometry instanceof MeshGeometry)\n        {\n            if (this._geometry.batchMode === 'auto')\n            {\n                return this._geometry.positions.length / 2 <= 100;\n            }\n\n            return this._geometry.batchMode === 'batch';\n        }\n\n        return false;\n    }\n\n    /**\n     * The local bounds of the mesh.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        return this._geometry.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this.geometry.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const { x, y } = point;\n\n        if (!this.bounds.containsPoint(x, y)) return false;\n\n        const vertices = this.geometry.getBuffer('aPosition').data;\n\n        const step = this.geometry.topology === 'triangle-strip' ? 3 : 1;\n\n        if (this.geometry.getIndex())\n        {\n            const indices = this.geometry.getIndex().data;\n            const len = indices.length;\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = indices[i] * 2;\n                const ind1 = indices[i + 1] * 2;\n                const ind2 = indices[i + 2] * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            const len = vertices.length / 2; // Each vertex has 2 coordinates, x and y\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = i * 2;\n                const ind1 = (i + 1) * 2;\n                const ind2 = (i + 2) * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /** @ignore */\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n\n        this._texture = null;\n        this._geometry = null;\n        this._shader = null;\n    }\n}\n", "import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { UPDATE_PRIORITY } from '../../ticker/const';\nimport { Ticker } from '../../ticker/Ticker';\nimport { Sprite } from '../sprite/Sprite';\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet}\n * containing the animation definitions:\n * @example\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * @memberof scene\n */\nexport class AnimatedSprite extends Sprite\n{\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed: number;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop: boolean;\n\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     * @default false\n     */\n    public updateAnchor: boolean;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite finishes playing.\n     * @example\n     * animation.onComplete = () => {\n     *     // Finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *     // Updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n     * loops around to start again.\n     * @example\n     * animation.onLoop = () => {\n     *     // Looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    private _playing: boolean;\n    private _textures: Texture[];\n    private _durations: number[];\n\n    /**\n     * `true` uses Ticker.shared to auto update animation time.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update animation time.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /** Elapsed time since animation has been started, used internally to display current texture. */\n    private _currentTime: number;\n\n    /** The texture index that was displayed last time. */\n    private _previousFrame: number;\n\n    /**\n     * @param textures - An array of {@link Texture} or frame\n     *  objects that make up the animation.\n     * @param {boolean} [autoUpdate=true] - Whether to use Ticker.shared to auto update animation time.\n     */\n    constructor(textures: Texture[] | FrameObject[], autoUpdate = true)\n    {\n        super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n\n        this._textures = null;\n        this._durations = null;\n        this._autoUpdate = autoUpdate;\n        this._isConnectedToTicker = false;\n\n        this.animationSpeed = 1;\n        this.loop = true;\n        this.updateAnchor = false;\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n\n        this._currentTime = 0;\n\n        this._playing = false;\n        this._previousFrame = null;\n\n        this.textures = textures;\n    }\n\n    /** Stops the AnimatedSprite. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the AnimatedSprite. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     * @param frameNumber - Frame index to stop at.\n     */\n    public gotoAndStop(frameNumber: number): void\n    {\n        this.stop();\n        this.currentFrame = frameNumber;\n    }\n\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     * @param frameNumber - Frame index to start at.\n     */\n    public gotoAndPlay(frameNumber: number): void\n    {\n        this.currentFrame = frameNumber;\n        this.play();\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * @param ticker - the ticker to use to update the object.\n     */\n    public update(ticker: Ticker): void\n    {\n        // If the animation isn't playing, no update is needed.\n        if (!this._playing)\n        {\n            return;\n        }\n\n        // Calculate elapsed time based on ticker's deltaTime and animation speed.\n        const deltaTime = ticker.deltaTime;\n        const elapsed = this.animationSpeed * deltaTime;\n        const previousFrame = this.currentFrame;\n\n        // If there are specific durations set for each frame:\n        if (this._durations !== null)\n        {\n            // Calculate the lag for the current frame based on the current time.\n            let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n            // Adjust the lag based on elapsed time.\n            lag += elapsed / 60 * 1000;\n\n            // If the lag is negative, adjust the current time and the lag.\n            while (lag < 0)\n            {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n\n            const sign = Math.sign(this.animationSpeed * deltaTime);\n\n            // Floor the current time to get a whole number frame.\n            this._currentTime = Math.floor(this._currentTime);\n\n            // Adjust the current time and the lag until the lag is less than the current frame's duration.\n            while (lag >= this._durations[this.currentFrame])\n            {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n\n            // Adjust the current time based on the lag and current frame's duration.\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else\n        {\n            // If no specific durations set, simply adjust the current time by elapsed time.\n            this._currentTime += elapsed;\n        }\n\n        // Handle scenarios when animation reaches the start or the end.\n        if (this._currentTime < 0 && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the start, go to the first frame.\n            this.gotoAndStop(0);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the end, go to the last frame.\n            this.gotoAndStop(this._textures.length - 1);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame)\n        {\n            // If the current frame is different from the last update, handle loop scenarios.\n            if (this.loop && this.onLoop)\n            {\n                if ((this.animationSpeed > 0 && this.currentFrame < previousFrame)\n                    || (this.animationSpeed < 0 && this.currentFrame > previousFrame))\n                {\n                    // If the animation loops, and there's an onLoop callback, call it.\n                    this.onLoop();\n                }\n            }\n\n            // Update the texture for the current frame.\n            this._updateTexture();\n        }\n    }\n\n    /** Updates the displayed texture to match the current frame index. */\n    private _updateTexture(): void\n    {\n        const currentFrame = this.currentFrame;\n\n        if (this._previousFrame === currentFrame)\n        {\n            return;\n        }\n\n        this._previousFrame = currentFrame;\n\n        this.texture = this._textures[currentFrame];\n\n        if (this.updateAnchor)\n        {\n            this.anchor.copyFrom(this.texture.defaultAnchor);\n        }\n\n        if (this.onFrameChange)\n        {\n            this.onFrameChange(this.currentFrame);\n        }\n    }\n\n    /** Stops the AnimatedSprite and destroys it. */\n    public destroy(): void\n    {\n        this.stop();\n        super.destroy();\n\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @returns - The new animated sprite with the specified frames.\n     */\n    public static fromFrames(frames: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < frames.length; ++i)\n        {\n            textures.push(Texture.from(frames[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @returns The new animate sprite with the specified images as frames.\n     */\n    public static fromImages(images: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < images.length; ++i)\n        {\n            textures.push(Texture.from(images[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     * @readonly\n     * @default 0\n     */\n    get totalFrames(): number\n    {\n        return this._textures.length;\n    }\n\n    /** The array of textures used for this AnimatedSprite. */\n    get textures(): Texture[] | FrameObject[]\n    {\n        return this._textures;\n    }\n\n    set textures(value: Texture[] | FrameObject[])\n    {\n        if (value[0] instanceof Texture)\n        {\n            this._textures = value as Texture[];\n            this._durations = null;\n        }\n        else\n        {\n            this._textures = [];\n            this._durations = [];\n\n            for (let i = 0; i < value.length; i++)\n            {\n                this._textures.push((value[i] as FrameObject).texture);\n                this._durations.push((value[i] as FrameObject).time);\n            }\n        }\n        this._previousFrame = null;\n        this.gotoAndStop(0);\n        this._updateTexture();\n    }\n\n    /** The AnimatedSprite's current frame index. */\n    get currentFrame(): number\n    {\n        let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n        if (currentFrame < 0)\n        {\n            currentFrame += this._textures.length;\n        }\n\n        return currentFrame;\n    }\n\n    set currentFrame(value: number)\n    {\n        if (value < 0 || value > this.totalFrames - 1)\n        {\n            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, `\n                + `expected to be between 0 and totalFrames ${this.totalFrames}.`);\n        }\n\n        const previousFrame = this.currentFrame;\n\n        this._currentTime = value;\n\n        if (previousFrame !== this.currentFrame)\n        {\n            this._updateTexture();\n        }\n    }\n\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     * @readonly\n     */\n    get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /** Whether to use Ticker.shared to auto update animation time. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n}\n\n/**\n * A reference to a frame in an {@link scene.AnimatedSprite}\n * @memberof scene\n */\nexport interface FrameObject\n{\n    /** The {@link Texture} of the frame. */\n    texture: Texture;\n\n    /** The duration of the frame, in milliseconds. */\n    time: number;\n}\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\n\nimport type { Observer } from '../../maths/point/ObservablePoint';\n\n/**\n * Options for the {@link utils.Transform} constructor.\n * @memberof utils.Transform\n */\nexport interface TransformOptions\n{\n    /** The matrix to use. */\n    matrix?: Matrix;\n    /** The observer to use. */\n    observer?: {_onUpdate: (transform: Transform) => void}\n}\n\n/**\n * The Transform class facilitates the manipulation of a 2D transformation matrix through\n * user-friendly properties: position, scale, rotation, skew, and pivot.\n * @memberof utils\n */\nexport class Transform\n{\n    /**\n     * The local transformation matrix.\n     * @internal\n     * @private\n     */\n    public _matrix: Matrix;\n\n    /** The coordinate of the object relative to the local coordinates of the parent. */\n    public position: ObservablePoint;\n\n    /** The scale factor of the object. */\n    public scale: ObservablePoint;\n\n    /** The pivot point of the container that it rotates around. */\n    public pivot: ObservablePoint;\n\n    /** The skew amount, on the x and y axis. */\n    public skew: ObservablePoint;\n\n    /** The rotation amount. */\n    protected _rotation: number;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _cx: number;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _sx: number;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _cy: number;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _sy: number;\n\n    protected dirty = true;\n    protected observer: Observer<Transform>;\n\n    /**\n     * @param options - Options for the transform.\n     * @param options.matrix - The matrix to use.\n     * @param options.observer - The observer to use.\n     */\n    constructor({ matrix, observer }: TransformOptions = {})\n    {\n        this._matrix = matrix ?? new Matrix();\n        this.observer = observer;\n\n        this.position = new ObservablePoint(this, 0, 0);\n        this.scale = new ObservablePoint(this, 1, 1);\n        this.pivot = new ObservablePoint(this, 0, 0);\n        this.skew = new ObservablePoint(this, 0, 0);\n\n        this._rotation = 0;\n        this._cx = 1;\n        this._sx = 0;\n        this._cy = 0;\n        this._sy = 1;\n    }\n\n    /**\n     * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot\n     * properties into a single matrix.\n     * @readonly\n     */\n    get matrix(): Matrix\n    {\n        const lt = this._matrix;\n\n        if (!this.dirty) return lt;\n\n        lt.a = this._cx * this.scale.x;\n        lt.b = this._sx * this.scale.x;\n        lt.c = this._cy * this.scale.y;\n        lt.d = this._sy * this.scale.y;\n\n        lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n        lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n\n        this.dirty = false;\n\n        return lt;\n    }\n    /**\n     * Called when a value changes.\n     * @param point\n     * @internal\n     * @private\n     */\n    public _onUpdate(point?: ObservablePoint): void\n    {\n        this.dirty = true;\n\n        if (point === this.skew)\n        {\n            this.updateSkew();\n        }\n\n        this.observer?._onUpdate(this);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    protected updateSkew(): void\n    {\n        this._cx = Math.cos(this._rotation + this.skew.y);\n        this._sx = Math.sin(this._rotation + this.skew.y);\n        this._cy = -Math.sin(this._rotation - this.skew.x); // cos, added PI/2\n        this._sy = Math.cos(this._rotation - this.skew.x); // sin, added PI/2\n\n        this.dirty = true;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Transform `\n            + `position=(${this.position.x}, ${this.position.y}) `\n            + `rotation=${this.rotation} `\n            + `scale=(${this.scale.x}, ${this.scale.y}) `\n            + `skew=(${this.skew.x}, ${this.skew.y}) `\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     * @param matrix - The matrix to decompose\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n        this.dirty = true;\n    }\n\n    /** The rotation of the object in radians. */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this.skew);\n        }\n    }\n}\n", "import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { Container } from '../container/Container';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends ContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends Container implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /** TODO */\n        applyAnchorToTexture: false,\n    };\n\n    public readonly renderPipeId = 'tilingSprite';\n    public readonly canBundle = true;\n    public readonly batched = true;\n\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n    public _applyAnchorToTexture: boolean;\n    public _didTilingSpriteUpdate: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    private _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this._applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    get width()\n    {\n        return this._width;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the tiling area. */\n    get height()\n    {\n        return this._height;\n    }\n\n    private _updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.maxX = -anchor._x * width;\n        bounds.minX = bounds.maxX + width;\n\n        bounds.maxY = -anchor._y * height;\n        bounds.minY = bounds.maxY + height;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const width = this.bounds.minX;\n        const height = this.bounds.minY;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._boundsDirty = true;\n        this._didTilingSpriteUpdate = true;\n\n        this._didChangeId += 1 << 12;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HtmlTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends Container implements View\n{\n    public abstract readonly renderPipeId: string;\n    public batched = true;\n    public _anchor: ObservablePoint;\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    public resolution: number = null;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n    public _roundPixels: 0 | 1 = 0;\n\n    protected _bounds: Bounds = new Bounds();\n    protected _boundsDirty = true;\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the text.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style = style || {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The local bounds of the Text.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this.bounds.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this.bounds.height);\n        }\n    }\n\n    /**\n     * Adds the bounds of this text to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const width = this.bounds.maxX;\n        const height = this.bounds.maxY;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._didChangeId += 1 << 12;\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        this._didTextUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public _getKey(): string\n    {\n        // TODO add a dirty flag...\n        return `${this.text}:${this._style.styleKey}`;\n    }\n\n    protected abstract _updateBounds(): void;\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n", "import { AbstractText, ensureOptions } from './AbstractText';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from './AbstractText';\nimport type { TextStyleOptions } from './TextStyle';\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and givae the `wordWrapWidth` property a value.\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class Text\n    extends AbstractText<TextStyle, TextStyleOptions>\n    implements View\n{\n    public readonly renderPipeId: string = 'text';\n\n    /**\n     * @param {text.TextOptions} options - The options of the text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'Text');\n\n        super(options, TextStyle);\n    }\n\n    protected _updateBounds()\n    {\n        const bounds = this._bounds;\n        const padding = this._style.padding;\n        const anchor = this._anchor;\n\n        const canvasMeasurement = CanvasTextMetrics.measureText(\n            this._text,\n            this._style\n        );\n\n        const { width, height } = canvasMeasurement;\n\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width + (padding * 2);\n        bounds.minY = (-anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + height + (padding * 2);\n    }\n}\n", "import { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { Container } from '../scene/container/Container';\nimport { Graphics } from '../scene/graphics/shared/Graphics';\nimport { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport { Mesh } from '../scene/mesh/shared/Mesh';\nimport { Sprite } from '../scene/sprite/Sprite';\nimport { AnimatedSprite } from '../scene/sprite-animated/AnimatedSprite';\nimport { TilingSprite } from '../scene/sprite-tiling/TilingSprite';\nimport { Text } from '../scene/text/Text';\nimport { PrepareBase } from './PrepareBase';\n\nimport type { FillInstruction, TextureInstruction } from '../scene/graphics/shared/GraphicsContext';\nimport type { FrameObject } from '../scene/sprite-animated/AnimatedSprite';\nimport type { PrepareQueueItem, PrepareSourceItem } from './PrepareBase';\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the base functionality and resolves given resource items ready for the queue.\n * @memberof rendering\n */\nexport abstract class PrepareQueue extends PrepareBase\n{\n    /**\n     * Resolve the given resource type and return an item for the queue\n     * @param source\n     * @param queue\n     */\n    protected resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void\n    {\n        if (source instanceof Container)\n        {\n            this.resolveContainerQueueItem(source, queue);\n        }\n        else if (source instanceof TextureSource || source instanceof Texture)\n        {\n            queue.push(source.source);\n        }\n        else if (source instanceof GraphicsContext)\n        {\n            queue.push(source);\n        }\n\n        // could not resolve the resource type\n        return null;\n    }\n\n    /**\n     * Resolve the given container and return an item for the queue\n     * @param container\n     * @param queue\n     */\n    protected resolveContainerQueueItem(container: Container, queue: PrepareQueueItem[]): void\n    {\n        // Note: we are just concerned with the given view.\n        // Children are handled by the recursive call of the base class\n\n        if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh)\n        {\n            queue.push(container.texture.source);\n        }\n        else if (container instanceof Text)\n        {\n            queue.push(container);\n        }\n        else if (container instanceof Graphics)\n        {\n            queue.push(container.context);\n        }\n        else if (container instanceof AnimatedSprite)\n        {\n            container.textures.forEach((textureOrFrame) =>\n            {\n                if ((textureOrFrame as Texture).source)\n                {\n                    queue.push((textureOrFrame as Texture).source);\n                }\n                else\n                {\n                    queue.push((textureOrFrame as FrameObject).texture.source);\n                }\n            });\n        }\n    }\n\n    /**\n     * Resolve the given graphics context and return an item for the queue\n     * @param graphicsContext\n     */\n    protected resolveGraphicsContextQueueItem(graphicsContext: GraphicsContext): PrepareQueueItem | null\n    {\n        this.renderer.graphicsContext.getContextRenderData(graphicsContext);\n\n        const { instructions } = graphicsContext;\n\n        for (const instruction of instructions)\n        {\n            if (instruction.action === 'texture')\n            {\n                const { image } = (instruction as TextureInstruction).data;\n\n                return image.source;\n            }\n            else if (instruction.action === 'fill')\n            {\n                const { texture } = (instruction as FillInstruction).data.style;\n\n                return texture.source;\n            }\n        }\n\n        return null;\n    }\n}\n", "import { AbstractText, ensureOptions } from '../text/AbstractText';\nimport { TextStyle } from '../text/TextStyle';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from '../text/AbstractText';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * A BitmapText Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * The text is created using a bitmap font (a sprite sheet of characters).\n *\n * The primary advantage of this render mode over `text` is that all of your textures are pre-generated and loaded,\n * meaning that rendering is fast, and changing text is much faster than Text.\n *\n * The primary disadvantage is that supporting character sets other than latin, such as CJK languages,\n * may be impractical due to the number of characters.\n *\n * <b>Pre-loaded BitmapFonts:</b>\n *\n *\n * PixiJS enables the loading of BitmapFonts through its Asset Manager, supporting both XML and FNT formats.\n * Additionally, PixiJS is compatible with MSDF (Multi-channel Signed Distance Field) and SDF (Signed Distance Field) fonts.\n * These advanced font types allow for scaling without quality degradation and must be created with specific tools,\n * such as the one available at https://msdf-bmfont.donmccurdy.com/.\n *\n * <b>Dynamically Generated BitmapFonts:</b>\n *\n *\n * PixiJS also offers the capability to generate BitmapFonts dynamically. This means that fonts are created in real-time\n * based on specified styles, eliminating the need for pre-loading. This process is initiated simply by assigning a style\n * to a BitmapText object, which then automatically generates the required font.\n *\n * However, dynamically generating a large number of fonts may lead to significant memory use. To prevent this,\n * PixiJS smartly attempts to reuse fonts that closely match the desired style parameters. For instance, if a text style\n * requires a font size of 80 but a similar font of size 100 has already been generated, PixiJS will scale the existing\n * font to fit the new requirement, rather than creating a new font from scratch.\n *\n * For those who prefer to manage BitmapFonts manually, PixiJS provides the BitmapFont.install method. This method\n * allows for the pre-generation and preparation of fonts, making them readily available for use by specifying the\n * fontFamily in your text styling.\n *\n * This approach ensures efficient font management within PixiJS, balancing between dynamic generation for flexibility\n * and manual management for optimized performance.\n * @example\n * import { BitmapText, BitmapFont } from 'pixi.js';\n *\n * // generate a dynamic font behind the scenes:\n * const text = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // pre install\n * BitmapFont.install({\n *    name: 'myFont',\n *    style:{\n *        fontFamily: 'Arial',\n *    }\n * })\n *\n * // new bitmap text with preinstalled font\n * const text = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myFont',\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * }\n *\n * // load a font from an xml file\n * const font = await Assets.load('path/to/myLoadedFont.fnt');\n *\n * // new bitmap text with loaded font\n * const text = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myLoadedFont', // the name of the font in the fnt file\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * }\n * @memberof scene\n */\nexport class BitmapText extends AbstractText<TextStyle, TextStyleOptions> implements View\n{\n    public readonly renderPipeId: string = 'bitmapText';\n\n    /**\n     * **Note:** Our docs parser struggles to properly understand the constructor signature.\n     * This is the correct signature.\n     * ```ts\n     * new BitmapText(options?: TextOptions);\n     * ```\n     * @param { text.TextOptions } options - The options of the bitmap text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'BitmapText');\n\n        options.style ??= options.style || {};\n        options.style.fill ??= 0xffffff;\n\n        super(options, TextStyle);\n    }\n\n    protected _updateBounds()\n    {\n        const bounds = this._bounds;\n        const padding = this._style.padding;\n        const anchor = this._anchor;\n\n        const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);\n        const scale = bitmapMeasurement.scale;\n        const offset = bitmapMeasurement.offsetY * scale;\n\n        const width = bitmapMeasurement.width * scale;\n        const height = bitmapMeasurement.height * scale;\n\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * (height + offset)) - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { AbstractText, ensureOptions } from '../text/AbstractText';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from '../text/AbstractText';\nimport type { HTMLTextStyleOptions } from './HtmlTextStyle';\n\n/**\n * Constructor options used for `HTMLText` instances.\n * @property {string} [text=''] - The string that you would like the text to display.\n * @property {text.HTMLTextStyle | text.HTMLTextStyleOptions} [style] - The style of the text.\n * @memberof text\n */\nexport type HTMLTextOptions = TextOptions<HTMLTextStyle, HTMLTextStyleOptions>;\n\n/**\n * A HTMLText Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * HTMLText uses an svg foreignObject to render HTML text.\n *\n *\n * The primary advantages of this render mode are:\n *\n *  - Supports [HTML tags](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/HTML_text_fundamentals)\n * for styling such as `<strong>`, or `<em>`, as well as `<span style=\"\">`\n *\n *       - Better support for emojis and other HTML layout features, better compatibility with CSS\n *     line-height and letter-spacing.\n *\n *\n * The primary disadvantages are:\n *   - Unlike `text`, `html` rendering will vary slightly between platforms and browsers.\n * `html` uses SVG/DOM to render text and not Context2D's fillText like `text`.\n *\n *   - Performance and memory usage is on-par with `text` (that is to say, slow and heavy)\n *\n *   - Only works with browsers that support <foreignObject>.\n * @example\n * import { HTMLText } from 'pixi.js';\n *\n * const text = new HTMLText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class HTMLText extends AbstractText<HTMLTextStyle, HTMLTextStyleOptions> implements View\n{\n    public readonly renderPipeId: string = 'htmlText';\n\n    /**\n     * @param {text.HTMLTextOptions} options - The options of the html text.\n     */\n    constructor(options?: HTMLTextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<HTMLTextStyle>);\n    constructor(...args: [HTMLTextOptions?] | [TextString, Partial<HTMLTextStyle>])\n    {\n        const options = ensureOptions<HTMLTextStyle, HTMLTextStyleOptions>(args, 'HtmlText');\n\n        super(options, HTMLTextStyle);\n    }\n\n    protected _updateBounds()\n    {\n        const bounds = this._bounds;\n        const padding = this._style.padding;\n        const anchor = this._anchor;\n\n        const htmlMeasurement = measureHtmlText(this.text, this._style as HTMLTextStyle);\n\n        const { width, height } = htmlMeasurement;\n\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport { Text } from '../scene/text/Text';\nimport { BitmapText } from '../scene/text-bitmap/BitmapText';\nimport { HTMLText } from '../scene/text-html/HTMLText';\nimport { PrepareQueue } from './PrepareQueue';\n\nimport type { FillInstruction, TextureInstruction } from '../scene/graphics/shared/GraphicsContext';\nimport type { PrepareQueueItem } from './PrepareBase';\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the resolver functionality and uploads the given queue items.\n * @memberof rendering\n */\nexport abstract class PrepareUpload extends PrepareQueue\n{\n    /**\n     * Upload the given queue item\n     * @param item\n     */\n    protected uploadQueueItem(item: PrepareQueueItem): void\n    {\n        if (item instanceof TextureSource)\n        {\n            this.uploadTextureSource(item);\n        }\n        else if (item instanceof Text)\n        {\n            this.uploadText(item);\n        }\n        else if (item instanceof HTMLText)\n        {\n            this.uploadHTMLText(item);\n        }\n        else if (item instanceof BitmapText)\n        {\n            this.uploadBitmapText(item);\n        }\n        else if (item instanceof GraphicsContext)\n        {\n            this.uploadGraphicsContext(item);\n        }\n    }\n\n    protected uploadTextureSource(textureSource: TextureSource): void\n    {\n        this.renderer.texture.initSource(textureSource);\n    }\n\n    protected uploadText(_text: Text): void\n    {\n        this.renderer.renderPipes.text.initGpuText(_text);\n    }\n\n    protected uploadBitmapText(_text: BitmapText): void\n    {\n        this.renderer.renderPipes.bitmapText.initGpuText(_text);\n    }\n\n    protected uploadHTMLText(_text: HTMLText): void\n    {\n        this.renderer.renderPipes.htmlText.initGpuText(_text);\n    }\n\n    /**\n     * Resolve the given graphics context and return an item for the queue\n     * @param graphicsContext\n     */\n    protected uploadGraphicsContext(graphicsContext: GraphicsContext): void\n    {\n        this.renderer.graphicsContext.getContextRenderData(graphicsContext);\n\n        const { instructions } = graphicsContext;\n\n        for (const instruction of instructions)\n        {\n            if (instruction.action === 'texture')\n            {\n                const { image } = (instruction as TextureInstruction).data;\n\n                this.uploadTextureSource(image.source);\n            }\n            else if (instruction.action === 'fill')\n            {\n                const { texture } = (instruction as FillInstruction).data.style;\n\n                this.uploadTextureSource(texture.source);\n            }\n        }\n\n        return null;\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { PrepareUpload } from './PrepareUpload';\n\nimport type { System } from '../rendering/renderers/shared/system/System';\n\n/**\n * The prepare system provides renderer-specific plugins for pre-rendering DisplayObjects. This is useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.prepare` property.\n * @example\n * import 'pixi.js/prepare';\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (prepare will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // Create a display object\n * const rect = new Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n * @memberof rendering\n */\nexport class PrepareSystem extends PrepareUpload implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'prepare',\n    } as const;\n\n    /** Destroys the plugin, don't use after this. */\n    public destroy(): void\n    {\n        clearTimeout(this.timeout);\n        this.renderer = null;\n        this.queue = null;\n        this.resolves = null;\n    }\n}\n"],
  "mappings": "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",
  "names": ["_PrepareBase", "_TilingSprite"]
}

{
  "version": 3,
  "sources": ["../../pixi.js/src/app/ResizePlugin.ts", "../../pixi.js/src/app/TickerPlugin.ts", "../../pixi.js/src/assets/loader/parsers/LoaderParser.ts", "../../pixi.js/src/utils/path.ts", "../../pixi.js/src/assets/utils/createStringVariations.ts", "../../pixi.js/src/assets/utils/isSingleItem.ts", "../../pixi.js/src/assets/resolver/Resolver.ts", "../../pixi.js/src/assets/utils/copySearchParams.ts", "../../pixi.js/src/spritesheet/Spritesheet.ts", "../../pixi.js/src/spritesheet/spritesheetAsset.ts", "../../pixi.js/src/spritesheet/init.ts", "../../pixi.js/src/rendering/mask/utils/addMaskBounds.ts", "../../pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts", "../../pixi.js/src/rendering/mask/alpha/AlphaMask.ts", "../../pixi.js/src/rendering/mask/color/ColorMask.ts", "../../pixi.js/src/rendering/mask/stencil/StencilMask.ts", "../../pixi.js/src/utils/browser/detectVideoAlphaMode.ts", "../../pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts", "../../pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts", "../../pixi.js/src/rendering/init.ts", "../../pixi.js/src/scene/graphics/shared/GraphicsPipe.ts", "../../pixi.js/src/scene/mesh/shared/BatchableMesh.ts", "../../pixi.js/src/scene/mesh/shared/MeshPipe.ts", "../../pixi.js/src/scene/text/canvas/CanvasTextPipe.ts", "../../pixi.js/src/utils/canvas/getCanvasBoundingBox.ts", "../../pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts", "../../pixi.js/src/scene/text/canvas/CanvasTextSystem.ts", "../../pixi.js/src/scene/text-bitmap/BitmapFont.ts", "../../pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts", "../../pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts", "../../pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts", "../../pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts", "../../pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts", "../../pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts", "../../pixi.js/src/scene/text/sdfShader/SdfShader.ts", "../../pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts", "../../pixi.js/src/scene/text-html/HTMLTextPipe.ts", "../../pixi.js/src/utils/browser/isSafari.ts", "../../pixi.js/src/scene/text-html/utils/extractFontFamilies.ts", "../../pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts", "../../pixi.js/src/scene/text-html/utils/loadFontCSS.ts", "../../pixi.js/src/scene/text-html/utils/getFontCss.ts", "../../pixi.js/src/scene/text-html/utils/getSVGUrl.ts", "../../pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts", "../../pixi.js/src/scene/text-html/utils/loadSVGImage.ts", "../../pixi.js/src/scene/text-html/HTMLTextSystem.ts", "../../pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts", "../../pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts", "../../pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts", "../../pixi.js/src/scene/sprite-tiling/utils/setPositions.ts", "../../pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts", "../../pixi.js/src/scene/sprite-tiling/utils/setUvs.ts", "../../pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts", "../../pixi.js/src/scene/mesh-plane/PlaneGeometry.ts", "../../pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts", "../../pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts", "../../pixi.js/src/filters/FilterPipe.ts", "../../pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts", "../../pixi.js/src/scene/container/bounds/getRenderableBounds.ts", "../../pixi.js/src/filters/FilterSystem.ts"],
  "sourcesContent": ["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n", "import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @enum {number}\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @memberof assets\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a ResolvedAsset) */\n    name: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void>;\n}\n", "import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @memberof utils\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @see {@link utils.Path}\n * @memberof utils\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n", "function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n", "/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n", "/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n", "import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof assets\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @memberof assets\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @memberof assets\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /** The maximum number of Textures to build per process. */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to ths source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n", "import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtension } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset, UnresolvedAsset } from '../assets/types';\nimport type { SpritesheetData } from './Spritesheet';\n\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[key] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *     }\n * })\n * @type {AssetExtension}\n * @memberof assets\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string): UnresolvedAsset =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        name: 'spritesheetLoader',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{texture: Texture, imageFilename: string, ignoreMultiPack: boolean}>,\n            loader: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename // if user need to use custom filename (not from jsonFile.meta.image)\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([imagePath]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet(\n                texture.source,\n                asset,\n            );\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            // eslint-disable-next-line camelcase\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    },\n} as AssetExtension<Spritesheet | SpriteSheetJson>;\n", "import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n", "import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n", "import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nexport function getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n", "import type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @memberof utils\n * @function detectVideoAlphaMode\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n", "// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\ntype VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @memberof rendering\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\nexport interface VideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * A source for video-based textures.\n * @memberof rendering\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement)\n            || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n", "import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions;\n\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: autoDetectSource(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\n", "import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\n/**\n * The rendering namespace contains all the classes used for core rendering in PixiJS\n * this includes all the lower level resources such as Textures, Shaders, State, Buffers,\n * Geometry and the systems required to use them. This covers WebGL and WebGPU and their shared classes.\n *\n * To automatically create a renderer based on available resources, see the {@link rendering.autoDetectRenderer} function.\n * @namespace rendering\n */\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', () =>\n            {\n                this.destroyRenderable(graphics);\n            });\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n", "import type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n", "import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n", "import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n", "import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        const padding = style.padding * 2;\n\n        context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n", "import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n            } = textures[charData.page];\n\n            const frameReal = new Rectangle(\n                charData.x + textureFrame.x,\n                charData.y + textureFrame.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n", "import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParser } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: ExtensionType.CacheParser,\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n};\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} as LoaderParser;\n", "// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n", "export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { maxRecommendedTextures } from '../../../rendering/renderers/shared/texture/utils/maxRecommendedTextures';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = maxRecommendedTextures();\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n", "import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n", "import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n", "import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n", "import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n", "import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n", "import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n", "import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n", "/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n", "export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n", "import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n", "import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh.texture._source !== renderable.texture._source)\n\n            { return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture); }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: State.default2d,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n", "import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n", "import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.renderGroup)\n    {\n        bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.renderGroup || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.renderGroup)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n", "import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const viewPort = renderer.renderTarget.rootViewPort;\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fitBounds(0, viewPort.width, 0, viewPort.height)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n"],
  "mappings": "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",
  "names": ["LoaderParserPriority", "path", "src", "_Spritesheet", "tempMatrix", "video", "_VideoSource", "tempBounds", "i", "i", "gpuProgram", "glProgram", "fontFamily", "resolve", "promise", "_PlaneGeometry", "_NineSliceGeometry", "tempMatrix", "filterData"]
}
